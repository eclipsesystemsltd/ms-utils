			      /* combine.c */
/* This program takes the 'results' file generated by program 'merge' and  */
/* reformats the information for screen display or printing.               */

/*
COMBINE.C

The command line input to this program is a definition file defining which
parts lists were merged by MRGE_ALL.C (i.e. MRGE00.RES to MRGEnn.RES).
COMBINE.C then reads the files generated by MRGE_ALL.C and displays part 
numbers and descriptions in a chronological order.

Note: This program modifies the files MRGE00.RES to MRGEnn.RES making them
useless for subsequent runs of COMBINE or PRN_MRGE. Therefore copy the MRGEnn
files if it is required to use them again.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "../ck_utils/ck_types.h"
#include "../ck_utils/ck_utils.h"

#define description_posn 8

int print_sorted_section(/*char descriptions[][80],
                          *char part_numbers[][10],
                          *int combinations[],*/
                         struct year years_covered[20],
                         int size);

int sort_years(int combinations[],
	       int print_order[200][2],
	       int size);

int print_years_covered(struct year years_covered[20],
		        int combination);

int bit_for_year[] = {  1,  2,   4,   8,  16,  32,   64,  128,
		      256,512,1024,2048,4096,8192,16384,32768};

int print_equiv_sections(int previous_file,
                 int file_limit,
		         char current_section[],
                 struct year years_covered[20]);

char descriptions[200][80];
char part_numbers[200][10];
int combinations[200];
int print_order[200][2];

void main(int argc,
	  char *argv[])
   {
   FILE *fptr_res;
   FILE *fptr_defn;
   struct part_years part_year_data;
   char defn_file[20][50];                      /* store definition file */
   char string_in[101];
//   char string_out[101];
   /* char years_covered[20][10]; */
   struct year years_covered[20];
   char file_name[40];
   char current_section[50];
   char next_section[50];
   int source_file;
//   int secondary_file;
   int title_posn;
   int row;
//   int no_of_years;
   int size;
//   int current_combination;
   int i; //,n;
   enum boolean first_section;
   enum boolean in_section;
   enum boolean another_section;

   if ((fptr_defn = fopen(argv[1],"r")) == NULL)
      {
      printf("Cannot open file %s \n",argv[1]);
      exit(0);
      }
   i = 0;
   while (fgets(string_in, 40, fptr_defn) != NULL)
      {
      str_build_1(defn_file[i],string_in);
      i++;
      };
   size = i;   /* the number of lines in definition file */
   if (strncmp(&defn_file[0][0],"*definition_file",16) != 0)  /* Check 1st line */
      {
      printf("Incorrect file type : %s\n",argv[1]);
      exit(0);
      }
   else
      {
      i = 1;
      while (strncmp(&defn_file[i][0],"*titles",7) != 0 &&
	     i < size)
	 i++;
      if (i == size - 1)
	 {
	 printf("No section titles found\n");
	 title_posn = i;
	 /* exit(); */
	 }
      else
	 title_posn = i;
      }
   /* Years and models covered information is stored in "MRGE00.RES" */
   for (i=0; i<20; i++)
      {
      years_covered[i].begin_string[0] = '\0';
      years_covered[i].end_string[0] = '\0';
      years_covered[i].begin_number = 0;
      years_covered[i].end_number = 0;
      }
   if ((fptr_res = fopen("MRGE00.RES","rb")) == NULL)
      {
      printf("Cannot open file %s\n","MRGE00.RES");
      exit(0);
      }
   while (fread(&part_year_data,sizeof(part_year_data), 1, fptr_res) != 0)
      {
      if (part_year_data.year[0][0] > 1000)
         {
         i = 0;
/* while (part_year_data.year[0][i] > 1000) */  /* Mentions all years */
         while (part_year_data.year[i][0] > 1000)  /* Mentions all years */
            {
/* printf ("%d ",part_year_data.year[0][1]);  */
            printf ("%d ",part_year_data.year[i][0]);
            i++;
            }
         printf("\n");
         i = 0;
/*  while (part_year_data.year[1][i] > 1000) */ /* Only covers first year of any ranges of years */
         while (part_year_data.year[i][1] > 1000) /* Only covers first year of any ranges of years */
            {
/* itoa(part_year_data.year[1][i],years_covered[i].begin_string,10);
 * itoa(part_year_data.year[2][i],years_covered[i].end_string,10);
 * years_covered[i].begin_number = part_year_data.year[1][i];
 * years_covered[i].end_number = part_year_data.year[2][i];  */
            _itoa(part_year_data.year[i][1],years_covered[i].begin_string,10);
            _itoa(part_year_data.year[i][2],years_covered[i].end_string,10);
            years_covered[i].begin_number = part_year_data.year[i][1];
            years_covered[i].end_number = part_year_data.year[i][2];
            i++;
            }
         }
      else
         printf("%s\n",part_year_data.description);
      }
   fclose(fptr_res);

   for (source_file = 1; source_file < title_posn; source_file++)   /* i.e. for each parts list (i.e. file) */
      {
      /* Open file */
      strcpy(file_name,"MRGE00.RES");
      make_temp_file_name(file_name,
			  4,
			  source_file);
      if ((fptr_res = fopen(file_name,"rb")) == NULL)
	 {
	 printf("Cannot open file %s\n",file_name);
         exit(0);
	 }
      first_section = true;
      another_section = false;
      in_section = false;
      while (fread(&part_year_data,sizeof(part_year_data), 1, fptr_res) != 0)
	 {
	 if (another_section == true)
            {
	    strcpy(current_section,next_section);
	    printf("\n");
	    printf(" %s\n",current_section);
	    printf(" ***\n");
	    another_section = false;
            in_section = true;
            row = 0;
	    }
         if (part_year_data.year[0][0] == -1)
	    {
	    if (first_section == true)
               {
	       printf(" %s\n",part_year_data.description);
	       strcpy(current_section,part_year_data.description);
	       first_section = false;
               row = 0;
	       }
	    else if (in_section == true)
               {
	       strcpy(next_section,part_year_data.description);
	       another_section = true;
	       /* Print data for same section from other files as must */
	       /* be at end of section in source file                  */
               print_sorted_section(/*descriptions,
                                     *part_numbers,
                                     *combinations,*/
                                    years_covered,
                                    row);
	       print_equiv_sections(source_file,
                                    title_posn,
			            current_section,
                                    years_covered);
	       }
	    else
               {
	       strcpy(next_section,part_year_data.description);
	       another_section = true;
	       }
            in_section = true;
	    }
	 else if (part_year_data.year[0][0] == -2)  /* i.e. a previously displayed section */
	    {
	    if (in_section == true)
               {
	       /* Print data for same section from other files as must */
	       /* be at end of section in source file                  */
               print_sorted_section(/*descriptions,
                                     *part_numbers,
                                     *combinations, */
                                    years_covered,
                                    row);
	       print_equiv_sections(source_file,
                                    title_posn,
			            current_section,
                                    years_covered);
	       }
	    in_section = false;
	    }
         else if (part_year_data.year[0][0] >= 0 &&
		  part_year_data.year[0][0] < 1000 &&
		  in_section == true)
	    {
            strcpy (descriptions[row],part_year_data.description);
            strcpy (part_numbers[row],part_year_data.part_number);
            combinations[row] = part_year_data.combination;
            row++;
            }
         else if (part_year_data.year[0][0] > 1900 &&    /* Display model years covered */
                  part_year_data.year[0][0] < 2000)
	    {
            ;
	    }
	 }
      if (in_section == true)
         {
         /* Print data for same section from other files */
         print_sorted_section(/*descriptions,
                               *part_numbers,
                               *combinations,*/
                              years_covered,
                              row);
	 print_equiv_sections(source_file,
                              title_posn,
	  		      current_section,
                              years_covered);
         }
      fclose(fptr_res);
      }
   }   /* main() */

int print_equiv_sections(int previous_file,
                 int file_limit,
		         char current_section[],
                 struct year years_covered[20])
   {
   FILE *fptr_sec;
   char file_name[20];
//   char string_out[101];
   /*char descriptions[100][80];
   *char part_numbers[100][10];
   *int combinations[100];*/
   int secondary_file;
   int row;
//   int j;
   struct part_years part_year_data;
   enum boolean in_section;
   fpos_t start_of_struct_last_read;
   fpos_t end_of_struct_last_read;

   /* Print out current section from other files */
   for (secondary_file = previous_file + 1; secondary_file < file_limit; secondary_file++)
      {
      /* printf("secondary %d\n",secondary_file); */
      /* Open file */
      strcpy(file_name,"MRGE00.RES");
      make_temp_file_name(file_name,
			  4,
			  secondary_file);
      if ((fptr_sec = fopen(file_name,"rb+")) == NULL)
         {
	 printf("Cannot open file %s\n",file_name);
	 exit(0);
	 }
      in_section = false;
      fgetpos(fptr_sec, &start_of_struct_last_read);
      while (fread(&part_year_data,sizeof(part_year_data), 1, fptr_sec) != 0)
         {
         fgetpos(fptr_sec, &end_of_struct_last_read);
	 if (part_year_data.year[0][0] == -1)
	    {
            if (in_section == true)
               {
               print_sorted_section(/*descriptions,
                                     *part_numbers,
                                     *combinations,*/
                                    years_covered,
                                    row);
               in_section = false;
               break;
               }
            else if (strcmp(current_section,part_year_data.description) == 0)
	       {
               in_section = true;
               row = 0;
               /* Mark section as found */
	       part_year_data.year[0][0] = -2;
	       if (fsetpos(fptr_sec, &start_of_struct_last_read) != 0)
	          printf("Error: fsetpos() error\n");
	       if (fwrite(&part_year_data,sizeof(part_year_data),1,fptr_sec) != 1)
                  {
	          printf("Marked structure not written\n");
		  }
	       fsetpos(fptr_sec, &end_of_struct_last_read);
	       }
	    }
	 else if (part_year_data.year[0][0] == -2 &&  /* Reached end of section */
                  in_section == true)
	    {
            print_sorted_section(/*descriptions,
                                  *part_numbers,
                                  *combinations,*/
                                 years_covered,
                                 row);
            in_section = false;
	    break;
            }
         else if (part_year_data.year[0][0] >= 0 &&
                  part_year_data.year[0][0] < 1000)
	    {
	    if (in_section == true)
	       {
               strcpy(descriptions[row],part_year_data.description);
               strcpy(part_numbers[row],part_year_data.part_number);
               combinations[row] = part_year_data.combination;
               row++;
 	       }
	    }
         fgetpos(fptr_sec, &start_of_struct_last_read);
	 }
      if (in_section == true)
         print_sorted_section(/*descriptions,
                               *part_numbers,
                               *combinations,*/
                              years_covered,
                              row);
      fclose(fptr_sec);
      }
   return 1;
   }  /*  print_equiv_sections()  */

int print_sorted_section(/*char descriptions[][80],
                          *char part_numbers[][10],
                          *int combinations[],*/
                         struct year years_covered[20],
                         int size)
   {
   char string_out[100];
   int print_order[200][2];
   int row;
   int current_combination;
   int i;

   sort_years(combinations,
              print_order,
	      size);
   print_years_covered(years_covered,     /* list years covered by first combination */
		       print_order[0][0]);
   current_combination = print_order[0][0];
   for (row = 0; row < size; row++)   
      {
      for (i=0; i < 100; i++)
         string_out[i] = ' ';
      if (combinations[print_order[row][1]] == current_combination)
         {
	 if (current_combination != 0)
            {
	    /* printf("%s  ",part_numbers[print_order[row][1]]); */
	    /* printf("%s\n",descriptions[print_order[row][1]]); */
            str_build(string_out,
                      part_numbers[print_order[row][1]]);
            strcpy(&string_out[description_posn], descriptions[print_order[row][1]]);
            printf("%s\n", string_out);
            }
         }
      else
	 {
	 current_combination = print_order[row][0];
	 if (current_combination != 0)
            {
	    print_years_covered(years_covered,
                                print_order[row][0]);
	    /* printf("%s  ",part_numbers[print_order[row][1]]); */
	    /* printf("%s\n",descriptions[print_order[row][1]]); */
            str_build(string_out,
                      part_numbers[print_order[row][1]]);
            strcpy(&string_out[description_posn], descriptions[print_order[row][1]]);
            printf("%s\n", string_out);
            }
	 }
      }
   return 1;
   } /* print_sorted_section() */

int print_years_covered(struct year years_covered[20],
		        int combination)
   {
   int i;
   int last_year;
//   char year_group[20];
   enum boolean in_group;
   enum boolean comma_needed;
    
   last_year = -1;
   comma_needed = false;
   in_group = false;
   printf("\n");
   for (i=0; i<16; i++)      /* !!! Actually will only do 15 years !!! */
      {
      if ((bit_for_year[i] & combination) == 0)      /* Note bitwise 'and' */
         {
         if (in_group == true)
            {
            /* printf("-%s",years_covered[last_year].string); */
            printf("-%s",years_covered[last_year].end_string);
            }
         else if (last_year != -1 &&
                  years_covered[last_year].end_number > years_covered[last_year].begin_number)
            printf("-%s",years_covered[last_year].end_string);
         in_group = false;
         last_year = -1;
         }
      else /* if ((bit_for_year[i] & combination) > 0) */
         {
         if (last_year == -1)
            {
            if (comma_needed == true)
               printf(", ");
            printf("%s",years_covered[i].begin_string);
            comma_needed = true;
            }
         else if (years_covered[i].begin_number == (years_covered[last_year].end_number + 1))
            {
            in_group = true;
            }
         else
            {
            if (in_group == true)
               {
               printf("-%s",years_covered[last_year].end_string);
               printf(", %s",years_covered[i].begin_string);
               in_group = false;
               }
            else
               printf(", %s",years_covered[i].begin_string);
            }
         last_year = i;
         }
      }
   printf("\n");
   return 1;
   }  /* print_years_covered() */

int sort_years(int combinations[],
	       int print_order[200][2],
	       int size)
   {
   int a,b,i,j;
   int last_reached;
   enum boolean lowest_combination_reached;

   for (i=0; i<200; i++)
      {
      print_order[i][0] = 0;
      print_order[i][1] = 0;
      }
   a = 16384;
   b = 0;
   j = 0;
   last_reached = 0;
   lowest_combination_reached = false;
   while (lowest_combination_reached == false)
      {
      lowest_combination_reached = true;
      for (i=0; i<size; i++)
         {
         if (combinations[i] < a)
            {
            if (b < combinations[i])
               {
               b = combinations[i];
               j = last_reached;
               lowest_combination_reached = false;
               print_order[j][0] = b;
               print_order[j][1] = i;
               j++;
               }
            else if (b == combinations[i])
               {
               print_order[j][0] = b;
               print_order[j][1] = i;
               j++;
               }
            }
         }
      a = b;
      b = 0;
      last_reached = j;
      }
   return(1);
   } /* sort_years() */

int sort_years_bubble(int combinations[],
	              int print_order[100][2],
	              int size)
   {
   int i, in, out, temp_a, temp_b;

   for (i=0; i<100; i++)
      {
      print_order[i][0] = 0;
      print_order[i][1] = 0;
      }
   for (i=0; i<size; i++) 
      {
      print_order[i][0] = combinations[i];
      print_order[i][1] = i;
      }
   for (out = 0; out < size-1; out++)
      for (in = out+1; in<size; in++)
	 if (print_order[out][0] < print_order[in][0])
	    {
	    temp_a = print_order[in][0];
	    temp_b = print_order[in][1];
	    print_order[in][0] = print_order[out][0];
	    print_order[in][1] = print_order[out][1];
	    print_order[out][0] = temp_a;
	    print_order[out][1] = temp_b;
	    }
   return(1);
   } /* sort_years_bubble() */

int print_years_covered_old(struct part_years results[],
                        int no_of_years,
			int row)
   {
   char year_string[5];
   char string_out[101];
   int year, place, i;

   for (i=0; i<101; i++)
      string_out[i] = ' ';

   place = 0;
   for (year = 0; year < no_of_years; year++)
      {
      if (results[row].year[year][0] > 0)
	 {
	 _itoa(results[0].year[year][0],year_string,10);
	 if (place > 0)
	    {
	    string_out[place] = ',';
	    place++;
	    }
	 str_build(&string_out[place],year_string);
	 place = place + 4;
	 }
      }
   string_out[place] = '\n';
   string_out[place + 1] = '\0';
   printf("%s",string_out);
   return(1);
   } /* print_years_covered() */


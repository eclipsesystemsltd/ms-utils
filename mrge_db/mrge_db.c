/*                              mrge_db.c                                 */
/* The purpose of this program is to merge two parts databases.           */

/*
MRGE_DB.C

The purpose of this program is to merge two databases. The databases must be
contained in data files of the type generated by MK_DBASE.C. Two database are
specified by the user and the contents of the second database is added into
the first.
*/

#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "../ck_utils/ck_types.h"
#include "../ck_utils/ck_utils.h"

int add_srce_data(struct part_info *base_ptr,
		  FILE *fptr_srce);

void main(int argc,
          char *argv[])
   {
   FILE *fptr_tgt;
   FILE *fptr_srce;
   struct part_info *base_ptr;
//   struct part_info *last_ptr;
//   struct part_info *new_ptr;
   struct part_info *cur_ptr;

   if ((fptr_tgt = fopen(argv[1],"rb")) == NULL)
      {
      printf("Cannot open file %s \n",argv[1]);
      exit(0);
      }
   if ((fptr_srce = fopen(argv[2],"rb")) == NULL)
      {
      printf("Cannot open file %s \n",argv[2]);
      exit(0);
      }
   if ((base_ptr = read_tgt_dbase(fptr_tgt)) == NULL)
      {
      printf("Insufficient memory for target database\n");
      exit(0);
      }
   else
      {
      if (add_srce_data(base_ptr,
			fptr_srce) == 0)
	 {
	 printf("Unable to merge databases\n");
         exit(0);
         }
      }
   fclose(fptr_tgt);                 /* Note danger of losing database */
   if ((fptr_tgt = fopen(argv[1],"wb")) == NULL)
      {
      printf("Cannot open file %s \n",argv[1]);
      exit(0);
      }
   cur_ptr = base_ptr;
   while (cur_ptr != NULL)
      {
      fwrite(cur_ptr,sizeof(struct part_info), 1, fptr_tgt);
      cur_ptr = cur_ptr->part_ptr;
      }
   fcloseall();
   }  /* main() */

int add_srce_data(struct part_info *base_ptr,
		  FILE *fptr_srce)
   {
   struct part_info *cur_ptr;
   struct part_info *new_ptr;
   struct part_info part_buf;
   int i,j,k;
   enum boolean part_found;
   enum boolean model_found;

   while(fread(&part_buf,sizeof(part_buf),1,fptr_srce) != 0)
      {
      cur_ptr = base_ptr;
      part_found = false;
      while (part_found == false)
	 {
	 if (strcmp(part_buf.part_number,cur_ptr->part_number) == 0)
	    {
	    part_found = true;
	    break;
	    }
	 else
	    {
	    if (cur_ptr->part_ptr == NULL)
	       break;
            else
	       cur_ptr = cur_ptr->part_ptr;
	    }
         }
      if (part_found == false)
	 {
         if ((new_ptr = (struct part_info *) malloc(sizeof(struct part_info))) == NULL)
	    return 0;
	 else
	    {
	    /* Fill in data for new entry to database */
	    *new_ptr = part_buf;
	    /* Update pointers */
	    cur_ptr->part_ptr = new_ptr;
	    new_ptr->part_ptr = NULL;
	    }
	 }
      else
	 {
	 /* Update existing database entry */
	 if (strcmp(cur_ptr->description,part_buf.description) != 0)
	    {
	    printf("Different Descriptions: %s\n",part_buf.part_number);
	    printf("   %s*\n",cur_ptr->description);
	    printf("   %s*\n",part_buf.description);
	    }
         i = 0;
	 while (cur_ptr->models[i] != 0)
	    i++;
	 j = 0;
	 while (part_buf.models[j] != 0 &&
		i < 20)
	    {
	    model_found = false;
	    for (k = 0; k <= i; k++)
	       if (part_buf.models[j] == cur_ptr->models[k])
	          {
		  model_found = true;
		  break;
		  }
	    if (model_found == false)
               {
	       cur_ptr->models[i] = part_buf.models[j];
               i++;
	       }
            j++;
	    }
	 if (i == 20)
            printf("Excess Models: %s\n",part_buf.part_number); 
	 }
      }
   return 1;
   }  /* add_srce_data() */